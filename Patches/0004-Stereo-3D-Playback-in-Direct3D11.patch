From 7c231351e8faf0bf2915f91384c22c0aa6e72a22 Mon Sep 17 00:00:00 2001
From: Mohammed Danish <shaan3@gmail.com>
Date: Fri, 7 Jul 2017 11:09:14 +0530
Subject: [PATCH 4/6] Stereo 3D Playback in Direct3D11

---
 modules/video_output/win32/direct3d11.c | 291 ++++++++++++++++++++++++++++----
 1 file changed, 258 insertions(+), 33 deletions(-)

diff --git a/modules/video_output/win32/direct3d11.c b/modules/video_output/win32/direct3d11.c
index f8082a28ee..09050461fa 100644
--- a/modules/video_output/win32/direct3d11.c
+++ b/modules/video_output/win32/direct3d11.c
@@ -98,7 +98,7 @@ typedef struct
     ID3D11Buffer              *pPixelShaderConstants[2];
     UINT                       PSConstantsCount;
     ID3D11PixelShader         *d3dpixelShader;
-    D3D11_VIEWPORT            cropViewport;
+    D3D11_VIEWPORT            cropViewport[2];
     unsigned int              i_x_offset;
     unsigned int              i_y_offset;
     unsigned int              i_width;
@@ -153,7 +153,7 @@ struct vout_display_sys_t
     DXGI_FORMAT              decoderFormat;
     picture_sys_t            stagingSys;
 
-    ID3D11RenderTargetView   *d3drenderTargetView;
+    ID3D11RenderTargetView   *d3drenderTargetView[2];
     ID3D11DepthStencilView   *d3ddepthStencilView;
 
     ID3D11VertexShader        *flatVSShader;
@@ -162,6 +162,8 @@ struct vout_display_sys_t
     /* copy from the decoder pool into picSquad before display
      * Uses a Texture2D with slices rather than a Texture2DArray for the decoder */
     bool                     legacy_shader;
+    bool                     stereo_enabled;
+    int                      source3DFormat;
 
     // SPU
     vlc_fourcc_t             pSubpictureChromas[2];
@@ -806,6 +808,73 @@ static void DestroyDisplayPoolPicture(picture_t *picture)
     free(p_sys);
     free(picture);
 }
+static int UpdateSwapChain(vout_display_t *vd, bool switch_to_2d)
+{
+    vout_display_sys_t *sys = vd->sys;
+    IDXGIFactory2 *dxgifactory;
+    HRESULT hr;
+
+    DXGI_SWAP_CHAIN_DESC1 scd;
+    ZeroMemory( &scd, sizeof(scd));
+    scd.BufferCount = 2;
+    scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+    scd.SampleDesc.Count = 1;
+    scd.SampleDesc.Quality = 0;
+    scd.Width = vd->source.i_visible_width;
+    scd.Height = vd->source.i_visible_height;
+    scd.Format = DXGI_FORMAT_R8G8B8A8_UNORM; /* TODO: use DXGI_FORMAT_NV12 */
+    scd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;    
+    scd.Stereo = switch_to_2d ? FALSE: TRUE;
+    scd.Scaling = DXGI_SCALING_NONE;
+    scd.Flags = 0;
+
+    IDXGIAdapter *dxgiadapter = D3D11DeviceAdapter(sys->d3ddevice);
+    if (FAILED(hr)) {
+       msg_Err(vd, "Could not get the DXGI Adapter");
+       return VLC_EGENERIC;
+    }
+
+    hr = IDXGIAdapter_GetParent(dxgiadapter, &IID_IDXGIFactory2, (void **)&dxgifactory);
+    IDXGIAdapter_Release(dxgiadapter);
+    if (FAILED(hr)) {
+       msg_Err(vd, "Could not get the DXGI Factory. (hr=0x%lX)", hr);
+       return VLC_EGENERIC;
+    }
+
+    //Release references to recreate the swapchain
+    if (sys->d3dcontext)
+    {
+        ID3D11DeviceContext_Flush(sys->d3dcontext);
+    }
+    if (sys->dxgiswapChain4)
+    {
+        IDXGISwapChain4_Release(sys->dxgiswapChain4);
+        sys->dxgiswapChain4 = NULL;
+    }
+    if (sys->dxgiswapChain)
+    {
+        IDXGISwapChain_Release(sys->dxgiswapChain);
+        sys->dxgiswapChain = NULL;
+    }
+    if (sys->d3drenderTargetView[0])
+    {
+        ID3D11RenderTargetView_Release(sys->d3drenderTargetView[0]);
+        sys->d3drenderTargetView[0] = NULL;
+    }
+    if (sys->d3drenderTargetView[1])
+    {
+        ID3D11RenderTargetView_Release(sys->d3drenderTargetView[1]);
+        sys->d3drenderTargetView[1] = NULL;
+    }
+
+    hr = IDXGIFactory2_CreateSwapChainForHwnd(dxgifactory, (IUnknown *)sys->d3ddevice,
+                                              sys->sys.hvideownd, &scd, NULL, NULL, &sys->dxgiswapChain);
+    IDXGIFactory2_Release(dxgifactory);
+    if (FAILED(hr)) {
+       msg_Err(vd, "Could not recreate the SwapChain. (hr=0x%lX)", hr);
+       return VLC_EGENERIC;
+    }
+}
 
 static HRESULT UpdateBackBuffer(vout_display_t *vd)
 {
@@ -821,9 +890,13 @@ static HRESULT UpdateBackBuffer(vout_display_t *vd)
     uint32_t i_width = RECTWidth(rect);
     uint32_t i_height = RECTHeight(rect);
 
-    if (sys->d3drenderTargetView) {
-        ID3D11RenderTargetView_Release(sys->d3drenderTargetView);
-        sys->d3drenderTargetView = NULL;
+    if (sys->d3drenderTargetView[0]) {
+        ID3D11RenderTargetView_Release(sys->d3drenderTargetView[0]);
+        sys->d3drenderTargetView[0] = NULL;
+    }
+    if (sys->d3drenderTargetView[1]) {
+        ID3D11RenderTargetView_Release(sys->d3drenderTargetView[1]);
+        sys->d3drenderTargetView[0] = NULL;
     }
     if (sys->d3ddepthStencilView) {
         ID3D11DepthStencilView_Release(sys->d3ddepthStencilView);
@@ -831,8 +904,12 @@ static HRESULT UpdateBackBuffer(vout_display_t *vd)
     }
 
     /* TODO detect is the size is the same as the output and switch to fullscreen mode */
-    hr = IDXGISwapChain_ResizeBuffers(sys->dxgiswapChain, 0, i_width, i_height,
-        DXGI_FORMAT_UNKNOWN, 0);
+    if (sys->stereo_enabled)
+        hr = IDXGISwapChain_ResizeBuffers(sys->dxgiswapChain, 4, i_width, i_height,
+                                      DXGI_FORMAT_UNKNOWN, 0);
+    else
+        hr = IDXGISwapChain_ResizeBuffers(sys->dxgiswapChain, 2, i_width, i_height,
+                                      DXGI_FORMAT_UNKNOWN, 0);
     if (FAILED(hr)) {
        msg_Err(vd, "Failed to resize the backbuffer. (hr=0x%lX)", hr);
        return hr;
@@ -844,7 +921,24 @@ static HRESULT UpdateBackBuffer(vout_display_t *vd)
        return hr;
     }
 
-    hr = ID3D11Device_CreateRenderTargetView(sys->d3ddevice, (ID3D11Resource *)pBackBuffer, NULL, &sys->d3drenderTargetView);
+    D3D11_RENDER_TARGET_VIEW_DESC renderTargetViewDesc;
+    ZeroMemory( &renderTargetViewDesc, sizeof( D3D11_RENDER_TARGET_VIEW_DESC));
+    renderTargetViewDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;    
+    renderTargetViewDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2DARRAY;
+    renderTargetViewDesc.Texture2DArray.MipSlice = 0;
+    renderTargetViewDesc.Texture2DArray.FirstArraySlice = 0;
+    renderTargetViewDesc.Texture2DArray.ArraySize = 1;
+
+    hr = ID3D11Device_CreateRenderTargetView(sys->d3ddevice, (ID3D11Resource *)pBackBuffer,
+                                             &renderTargetViewDesc, &sys->d3drenderTargetView[0]);
+
+    if (sys->stereo_enabled)
+    {
+        renderTargetViewDesc.Texture2DArray.FirstArraySlice = 1;
+        hr = ID3D11Device_CreateRenderTargetView(sys->d3ddevice, (ID3D11Resource *)pBackBuffer,
+                                                 &renderTargetViewDesc, &sys->d3drenderTargetView[1]);
+    }
+
     ID3D11Texture2D_Release(pBackBuffer);
     if (FAILED(hr)) {
         msg_Err(vd, "Failed to create the target view. (hr=0x%lX)", hr);
@@ -1077,6 +1171,31 @@ static int Control(vout_display_t *vd, int query, va_list args)
             res = VLC_SUCCESS;
         }
     }
+    else if (query == VOUT_DISPLAY_CHANGE_MULTIVIEW)
+    {
+        const vout_display_cfg_t *cfg = va_arg(args, const vout_display_cfg_t*);
+        //Disable Stereoscopic 3D if 2D output is selected
+        if ((cfg->multiview_format == VIDEO_STEREO_OUTPUT_RIGHT_ONLY) || (cfg->multiview_format == VIDEO_STEREO_OUTPUT_LEFT_ONLY))
+        {
+            if (sys->stereo_enabled)
+            {                
+                sys->stereo_enabled = false;
+                res = UpdateSwapChain(vd, true);
+            }            
+        }
+        else if (cfg->multiview_format == VIDEO_STEREO_OUTPUT_AUTO)
+        {
+            if (!sys->stereo_enabled)
+            {                
+                sys->stereo_enabled = true;
+                res = UpdateSwapChain(vd, false);
+            }
+        }
+
+        UpdateBackBuffer(vd);
+        UpdatePicQuadPosition(vd);
+        res = VLC_SUCCESS;
+    }
 
     if (RECTWidth(size_before)  != RECTWidth(sys->sys.rect_dest_clipped) ||
         RECTHeight(size_before) != RECTHeight(sys->sys.rect_dest_clipped))
@@ -1156,7 +1275,7 @@ static void Prepare(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
 #endif
 }
 
-static void DisplayD3DPicture(vout_display_sys_t *sys, d3d_quad_t *quad, ID3D11ShaderResourceView *resourceView[D3D11_MAX_SHADER_VIEW])
+static void DisplayD3DPicture(vout_display_sys_t *sys, d3d_quad_t *quad, ID3D11ShaderResourceView *resourceView[D3D11_MAX_SHADER_VIEW], int eyeIndex)
 {
     UINT stride = sizeof(d3d_vertex_t);
     UINT offset = 0;
@@ -1176,7 +1295,10 @@ static void DisplayD3DPicture(vout_display_sys_t *sys, d3d_quad_t *quad, ID3D11S
     ID3D11DeviceContext_PSSetConstantBuffers(sys->d3dcontext, 0, quad->PSConstantsCount, quad->pPixelShaderConstants);
     ID3D11DeviceContext_PSSetShaderResources(sys->d3dcontext, 0, D3D11_MAX_SHADER_VIEW, resourceView);
 
-    ID3D11DeviceContext_RSSetViewports(sys->d3dcontext, 1, &quad->cropViewport);
+    if (eyeIndex)
+        ID3D11DeviceContext_RSSetViewports(sys->d3dcontext, 1, &quad->cropViewport[1]);
+    else
+        ID3D11DeviceContext_RSSetViewports(sys->d3dcontext, 1, &quad->cropViewport[0]);
 
     ID3D11DeviceContext_DrawIndexed(sys->d3dcontext, quad->indexCount, 0, 0);
 }
@@ -1184,6 +1306,8 @@ static void DisplayD3DPicture(vout_display_sys_t *sys, d3d_quad_t *quad, ID3D11S
 static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpicture)
 {
     vout_display_sys_t *sys = vd->sys;
+    int s3d_format_selection = var_InheritInteger (vd, "video-stereo-mode");
+
 #ifdef HAVE_ID3D11VIDEODECODER
     if (sys->context_lock != INVALID_HANDLE_VALUE && is_d3d11_opaque(picture->format.i_chroma))
     {
@@ -1192,20 +1316,31 @@ static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
 #endif
 
     FLOAT blackRGBA[4] = {0.0f, 0.0f, 0.0f, 1.0f};
-    ID3D11DeviceContext_ClearRenderTargetView(sys->d3dcontext, sys->d3drenderTargetView, blackRGBA);
+    ID3D11DeviceContext_ClearRenderTargetView(sys->d3dcontext, sys->d3drenderTargetView[0], blackRGBA);
 
     /* no ID3D11Device operations should come here */
 
-    ID3D11DeviceContext_OMSetRenderTargets(sys->d3dcontext, 1, &sys->d3drenderTargetView, sys->d3ddepthStencilView);
+    ID3D11DeviceContext_OMSetRenderTargets(sys->d3dcontext, 1, &sys->d3drenderTargetView[0], sys->d3ddepthStencilView);
 
     ID3D11DeviceContext_ClearDepthStencilView(sys->d3dcontext, sys->d3ddepthStencilView, D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);
 
     /* Render the quad */
     if (!is_d3d11_opaque(picture->format.i_chroma) || sys->legacy_shader)
-        DisplayD3DPicture(sys, &sys->picQuad, sys->stagingSys.resourceView);
+    {
+        DisplayD3DPicture(sys, &sys->picQuad, sys->stagingSys.resourceView, 0);
+        if (sys->stereo_enabled)
+        {
+            ID3D11DeviceContext_OMSetRenderTargets(sys->d3dcontext, 1, &sys->d3drenderTargetView[1], sys->d3ddepthStencilView);
+            //If 3D output is auto-detect but has no metadata
+            if ((s3d_format_selection == VIDEO_STEREO_OUTPUT_RIGHT_ONLY) && (sys->source3DFormat == MULTIVIEW_2D))
+                DisplayD3DPicture(sys, &sys->picQuad, sys->stagingSys.resourceView, 0);
+            else
+                DisplayD3DPicture(sys, &sys->picQuad, sys->stagingSys.resourceView, 1);
+        }
+    }
     else {
         picture_sys_t *p_sys = ActivePictureSys(picture);
-        DisplayD3DPicture(sys, &sys->picQuad, p_sys->resourceView);
+        DisplayD3DPicture(sys, &sys->picQuad, p_sys->resourceView, 0);
     }
 
     if (subpicture) {
@@ -1214,7 +1349,7 @@ static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
             if (sys->d3dregions[i])
             {
                 d3d_quad_t *quad = (d3d_quad_t *) sys->d3dregions[i]->p_sys;
-                DisplayD3DPicture(sys, quad, quad->picSys.resourceView);
+                DisplayD3DPicture(sys, quad, quad->picSys.resourceView, 0);
             }
         }
     }
@@ -1451,6 +1586,9 @@ static int Direct3D11Open(vout_display_t *vd, video_format_t *fmt)
 {
     vout_display_sys_t *sys = vd->sys;
     IDXGIFactory2 *dxgifactory;
+    static int multiview_mode_remember = 0;
+    int s3d_format_selection = var_InheritInteger (vd, "video-stereo-mode");
+    D3D_FEATURE_LEVEL i_feature_level;
 
     *fmt = vd->source;
 
@@ -1499,8 +1637,7 @@ static int Direct3D11Open(vout_display_t *vd, video_format_t *fmt)
     };
 
     for (UINT driver = 0; driver < ARRAYSIZE(driverAttempts); driver++) {
-        D3D_FEATURE_LEVEL i_feature_level;
-        hr = D3D11CreateDevice(NULL, driverAttempts[driver], NULL, creationFlags,
+            hr = D3D11CreateDevice(NULL, driverAttempts[driver], NULL, creationFlags,
                     NULL, 0, D3D11_SDK_VERSION,
                     &sys->d3ddevice, &i_feature_level, &sys->d3dcontext);
         if (SUCCEEDED(hr)) {
@@ -1518,6 +1655,10 @@ static int Direct3D11Open(vout_display_t *vd, video_format_t *fmt)
        return VLC_EGENERIC;
     }
 
+    if (i_feature_level < D3D_FEATURE_LEVEL_10_0) {
+        msg_Dbg(vd, "Could not create the 3D11 device for Stereoscopic 3D. 3D won't work.");
+    }
+
     IDXGIAdapter *dxgiadapter = D3D11DeviceAdapter(sys->d3ddevice);
     if (unlikely(dxgiadapter==NULL)) {
        msg_Err(vd, "Could not get the DXGI Adapter");
@@ -1531,6 +1672,36 @@ static int Direct3D11Open(vout_display_t *vd, video_format_t *fmt)
        return VLC_EGENERIC;
     }
 
+    //Disable 3D if not supported by the system
+    sys->stereo_enabled = i_feature_level >= D3D_FEATURE_LEVEL_10_0 &&
+            IDXGIFactory2_IsWindowedStereoEnabled(dxgifactory);
+    //Since the next immediate call doesn't have 3D state information which we need to use again
+    sys->source3DFormat = fmt->multiview_mode;
+    if (multiview_mode_remember != 0)
+    {
+       fmt->multiview_mode = multiview_mode_remember;
+       sys->source3DFormat = (multiview_mode_remember == MULTIVIEW_STEREO_SBS) ?
+                   MULTIVIEW_STEREO_SBS : MULTIVIEW_STEREO_TB;
+       multiview_mode_remember = 0;
+    }
+    else if ((fmt->multiview_mode == MULTIVIEW_STEREO_SBS) && (s3d_format_selection == VIDEO_STEREO_OUTPUT_RIGHT_ONLY))
+    {
+        multiview_mode_remember = MULTIVIEW_STEREO_SBS;
+    }
+    else if ((fmt->multiview_mode == MULTIVIEW_STEREO_TB) && (s3d_format_selection == VIDEO_STEREO_OUTPUT_RIGHT_ONLY))
+    {
+        multiview_mode_remember = MULTIVIEW_STEREO_TB;
+    }
+    else if ((fmt->multiview_mode == MULTIVIEW_2D) && (s3d_format_selection == VIDEO_STEREO_OUTPUT_RIGHT_ONLY))
+        sys->stereo_enabled = false;
+
+    if (sys->stereo_enabled)
+    {
+        scd.Stereo = TRUE;
+        scd.Scaling = DXGI_SCALING_NONE;
+        scd.Flags = 0;
+    }
+
     hr = IDXGIFactory2_CreateSwapChainForHwnd(dxgifactory, (IUnknown *)sys->d3ddevice,
                                               sys->sys.hvideownd, &scd, NULL, NULL, &sys->dxgiswapChain);
     IDXGIFactory2_Release(dxgifactory);
@@ -1666,19 +1837,68 @@ static void Direct3D11Close(vout_display_t *vd)
 static void UpdatePicQuadPosition(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
+    int s3d_format_selection = var_InheritInteger (vd, "video-stereo-mode");
 
-    sys->picQuad.cropViewport.Width    = RECTWidth(sys->sys.rect_dest_clipped);
-    sys->picQuad.cropViewport.Height   = RECTHeight(sys->sys.rect_dest_clipped);
-    sys->picQuad.cropViewport.TopLeftX = sys->sys.rect_dest_clipped.left;
-    sys->picQuad.cropViewport.TopLeftY = sys->sys.rect_dest_clipped.top;
+    //Default 2D mode selection
+    if ((!sys->stereo_enabled) || ((sys->stereo_enabled) && (s3d_format_selection == VIDEO_STEREO_OUTPUT_AUTO) && (sys->source3DFormat == MULTIVIEW_2D)))
+    {
+        sys->picQuad.cropViewport[0].Width    = RECTWidth(sys->sys.rect_dest_clipped);
+        sys->picQuad.cropViewport[0].Height   = RECTHeight(sys->sys.rect_dest_clipped);
+        sys->picQuad.cropViewport[0].TopLeftX = sys->sys.rect_dest_clipped.left;
+        sys->picQuad.cropViewport[0].TopLeftY = sys->sys.rect_dest_clipped.top;
+    }
+    //For stereoscopic side by side left-right format
+    else if (((s3d_format_selection == VIDEO_STEREO_OUTPUT_AUTO) || ( sys->source3DFormat == MULTIVIEW_STEREO_SBS)) && (sys->stereo_enabled))
+    {
+        sys->picQuad.cropViewport[0].Width    = RECTWidth(sys->sys.rect_dest_clipped) * 2;
+        sys->picQuad.cropViewport[0].Height   = RECTHeight(sys->sys.rect_dest_clipped);
+        sys->picQuad.cropViewport[0].TopLeftX = sys->sys.rect_dest_clipped.left;
+        sys->picQuad.cropViewport[0].TopLeftY = sys->sys.rect_dest_clipped.top;
+
+        sys->picQuad.cropViewport[1].Width    = RECTWidth(sys->sys.rect_dest_clipped) * 2;
+        sys->picQuad.cropViewport[1].Height   = RECTHeight(sys->sys.rect_dest_clipped);
+        sys->picQuad.cropViewport[1].TopLeftX = sys->sys.rect_dest_clipped.left - RECTWidth(sys->sys.rect_dest_clipped);
+        sys->picQuad.cropViewport[1].TopLeftY = sys->sys.rect_dest_clipped.top;
+        sys->picQuad.cropViewport[1].MinDepth = 0.0f;
+        sys->picQuad.cropViewport[1].MaxDepth = 1.0f;
+    }
+    //For stereoscopic side by side top-bottom format
+    else if ((( sys->source3DFormat == MULTIVIEW_STEREO_TB)) && (sys->stereo_enabled))
+    {
+        sys->picQuad.cropViewport[0].Width    = RECTWidth(sys->sys.rect_dest_clipped);
+        sys->picQuad.cropViewport[0].Height   = RECTHeight(sys->sys.rect_dest_clipped) * 2;
+        sys->picQuad.cropViewport[0].TopLeftX = sys->sys.rect_dest_clipped.left;
+        sys->picQuad.cropViewport[0].TopLeftY = sys->sys.rect_dest_clipped.top;
+
+        sys->picQuad.cropViewport[1].Width    = RECTWidth(sys->sys.rect_dest_clipped);
+        sys->picQuad.cropViewport[1].Height   = RECTHeight(sys->sys.rect_dest_clipped) * 2;
+        sys->picQuad.cropViewport[1].TopLeftX = sys->sys.rect_dest_clipped.left;
+        sys->picQuad.cropViewport[1].TopLeftY = sys->sys.rect_dest_clipped.top - RECTHeight(sys->sys.rect_dest_clipped);
+        sys->picQuad.cropViewport[1].MinDepth = 0.0f;
+        sys->picQuad.cropViewport[1].MaxDepth = 1.0f;
+    }
 
-    sys->picQuad.cropViewport.MinDepth = 0.0f;
-    sys->picQuad.cropViewport.MaxDepth = 1.0f;
+    if (s3d_format_selection == VIDEO_STEREO_OUTPUT_LEFT_ONLY)
+    {
+        sys->picQuad.cropViewport[0].Width    = RECTWidth(sys->sys.rect_dest_clipped) * 2;
+        sys->picQuad.cropViewport[0].Height   = RECTHeight(sys->sys.rect_dest_clipped);
+        sys->picQuad.cropViewport[0].TopLeftX = sys->sys.rect_dest_clipped.left;
+        sys->picQuad.cropViewport[0].TopLeftY = sys->sys.rect_dest_clipped.top;
+    }
+    else if (s3d_format_selection == VIDEO_STEREO_OUTPUT_RIGHT_ONLY)
+    {
+        sys->picQuad.cropViewport[0].Width    = RECTWidth(sys->sys.rect_dest_clipped) * 2;
+        sys->picQuad.cropViewport[0].Height   = RECTHeight(sys->sys.rect_dest_clipped);
+        sys->picQuad.cropViewport[0].TopLeftX = sys->sys.rect_dest_clipped.left - RECTWidth(sys->sys.rect_dest_clipped);
+        sys->picQuad.cropViewport[0].TopLeftY = sys->sys.rect_dest_clipped.top;
+    }
+    sys->picQuad.cropViewport[0].MinDepth = 0.0f;
+    sys->picQuad.cropViewport[0].MaxDepth = 1.0f;
 
     SetQuadVSProjection(vd, &sys->picQuad, &vd->cfg->viewpoint);
 
 #ifndef NDEBUG
-    msg_Dbg(vd, "picQuad position (%.02f,%.02f) %.02fx%.02f", sys->picQuad.cropViewport.TopLeftX, sys->picQuad.cropViewport.TopLeftY, sys->picQuad.cropViewport.Width, sys->picQuad.cropViewport.Height );
+    msg_Dbg(vd, "picQuad position (%.02f,%.02f) %.02fx%.02f", sys->picQuad.cropViewport[0].TopLeftX, sys->picQuad.cropViewport[0].TopLeftY, sys->picQuad.cropViewport[0].Width, sys->picQuad.cropViewport[0].Height );
 #endif
 }
 
@@ -2629,10 +2849,15 @@ static void Direct3D11DestroyResources(vout_display_t *vd)
         ID3D11VertexShader_Release(sys->projectionVSShader);
         sys->projectionVSShader = NULL;
     }
-    if (sys->d3drenderTargetView)
+    if (sys->d3drenderTargetView[0])
+    {
+        ID3D11RenderTargetView_Release(sys->d3drenderTargetView[0]);
+        sys->d3drenderTargetView[0] = NULL;
+    }
+    if (sys->d3drenderTargetView[1])
     {
-        ID3D11RenderTargetView_Release(sys->d3drenderTargetView);
-        sys->d3drenderTargetView = NULL;
+        ID3D11RenderTargetView_Release(sys->d3drenderTargetView[1]);
+        sys->d3drenderTargetView[1] = NULL;
     }
     if (sys->d3ddepthStencilView)
     {
@@ -2806,12 +3031,12 @@ static int Direct3D11MapSubpicture(vout_display_t *vd, int *subpicture_region_co
 
         d3d_quad_t *quad = (d3d_quad_t *) quad_picture->p_sys;
 
-        quad->cropViewport.Width =  (FLOAT) r->fmt.i_visible_width  * RECTWidth(sys->sys.rect_dest)  / subpicture->i_original_picture_width;
-        quad->cropViewport.Height = (FLOAT) r->fmt.i_visible_height * RECTHeight(sys->sys.rect_dest) / subpicture->i_original_picture_height;
-        quad->cropViewport.MinDepth = 0.0f;
-        quad->cropViewport.MaxDepth = 1.0f;
-        quad->cropViewport.TopLeftX = sys->sys.rect_dest.left + (FLOAT) r->i_x * RECTWidth(sys->sys.rect_dest) / subpicture->i_original_picture_width;
-        quad->cropViewport.TopLeftY = sys->sys.rect_dest.top  + (FLOAT) r->i_y * RECTHeight(sys->sys.rect_dest) / subpicture->i_original_picture_height;
+        quad->cropViewport[0].Width =  (FLOAT) r->fmt.i_visible_width  * RECTWidth(sys->sys.rect_dest)  / subpicture->i_original_picture_width;
+        quad->cropViewport[0].Height = (FLOAT) r->fmt.i_visible_height * RECTHeight(sys->sys.rect_dest) / subpicture->i_original_picture_height;
+        quad->cropViewport[0].MinDepth = 0.0f;
+        quad->cropViewport[0].MaxDepth = 1.0f;
+        quad->cropViewport[0].TopLeftX = sys->sys.rect_dest.left + (FLOAT) r->i_x * RECTWidth(sys->sys.rect_dest) / subpicture->i_original_picture_width;
+        quad->cropViewport[0].TopLeftY = sys->sys.rect_dest.top  + (FLOAT) r->i_y * RECTHeight(sys->sys.rect_dest) / subpicture->i_original_picture_height;
 
         UpdateQuadOpacity(vd, quad, r->i_alpha / 255.0f );
     }
-- 
2.12.2.windows.2

